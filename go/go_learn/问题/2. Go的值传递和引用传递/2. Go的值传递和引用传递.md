



### 疑问的开始: map[key].xxx调用为什么报错?

```go
// idsMap["basic"] 和 promotionIds 不一样. 说明是map[key] 是复制返回的v
var idsMap = make(map[string][]int64)
idsMap["basic"] = make([]int64,0)

var promotionIds = idsMap["basic"]
promotionIds = append(promotionIds, 1)
promotionIds = append(promotionIds, 2)
promotionIds = append(promotionIds, 3)
promotionIds = append(promotionIds, 4)
fmt.Printf("%+v", idsMap)
fmt.Printf("%+v", promotionIds)
```



### 原来是: value是not addressable的.

[proposal: spec: cannot assign to a field of a map element directly: m["foo"\].f = x · Issue #3117 · golang/go (github.com)](https://github.com/golang/go/issues/3117#issuecomment-430632750)

这个里面说的, value是不可变的. 本质不是值传递和引用传递. 两个问题.





### 疑问: Go是值传递和地址传递?  

**和Java一样, 完全是值传递**, 但是也分引用类型和值类型, 所以入参引用和值的区分.

<img src="2. Go的值传递和引用传递.assets/image-20220121171439442.png" alt="image-20220121171439442" style="zoom: 20%;" />







### 错误的第一理解: ❌ 问题的本质其实是 引用类型

>  原本理解: 返回value是真实的value, 方法入参传递的是值的拷贝(指针就是指针的拷贝)
>
>  现在理解: 返回值和入参没有区别, 都是值拷贝. 只是有引用类型和值类型之分.
>
> 引用类型: 变量存的是地址, 也是把地址拷贝进去. 
>
> 值类型: 变量存的就是值, 拷贝进去就好.







```go
func main() {
// 入参: 值拷贝
	// 返回值是值, 不是拷贝
	var ids = make([]int64, 0)
	var ids2 []int64 = addSome(ids)

	fmt.Printf("外面 ids: %+p\n", ids)
	fmt.Printf("外面 ids: %+v\n", ids)
	fmt.Printf("外面 ids2: %+p\n", ids2)
	fmt.Printf("外面 ids2: %+v\n", ids2)
}
func addSome(ids1 []int64) []int64 {
	ids1 = append(ids1, 1)
	ids1 = append(ids1, 2)
	ids1 = append(ids1, 3)
	fmt.Printf("ids1: %+p\n", ids1)
	fmt.Printf("ids1: %+v\n", ids1)

	return ids1
}

// 期望结果:
// 1. 入参值拷贝: ids1 是 ids 的拷贝, 两个地址和value不同
// 2. 返回原值: ids2 和 ids1 是完全相同的
```





### 真实的第二理解: 本质是 引用类型 和 值类型

[go-值类型与引用类型 - Go语言中文网 - Golang中文社区 (studygolang.com)](https://studygolang.com/articles/27252)

Java里面基础类型全是值类型, 非基础类型全是引用类型.

Go里面没有基础类型的概念. 全是一样平等的数据类型. [Go 语言数据类型](https://www.runoob.com/go/go-data-types.html)

- 值类型分别有：int系列、float系列、bool、string、数组和结构体
- 引用类型有：指针、slice切片、管道channel、接口interface、map、函数等. 
- !!!!!!!!引用类型在赋值的时候, 也是值拷贝后传递!!! 只是在传递成入参的时候, 是传递指针.

值类型的特点是: 变量直接存储值, 内存通常在栈中分配

引用类型的特点是: 变量存储的是一个地址, 这个地址对应的空间里才是真正存储的值, 内存通常在堆中分配



注意: array 是值类型. slice 是引用类型, slice 是在 array 基础上操作的.

对引用类型入参, 在方法内的操作, 还是对同一个地址操作. 只是对指针的重新赋值, 外面的指针不会拿到.

例子: 

```go
func main() {
// 入参: 值拷贝
	// 返回值是值, 不是拷贝
	var ids = make([]int64, 0)
	var ids2 []int64 = addSome(ids)

	fmt.Printf("外面 ids: %+p\n", ids)
	fmt.Printf("外面 ids: %+v\n", ids)
	fmt.Printf("外面 ids2: %+p\n", ids2)
	fmt.Printf("外面 ids2: %+v\n", ids2)
}
func addSome(ids1 []int64) []int64 {
	ids1 = append(ids1, 1)
	ids1 = append(ids1, 2)
	ids1 = append(ids1, 3)
	fmt.Printf("ids1: %+p\n", ids1)
	fmt.Printf("ids1: %+v\n", ids1)

	return ids1
}

// 期望: 
// 刚传进去的ids1, 和 ids 地址是一个. 都指向了一个 slice 对象.
// 只是后面扩容的时候, ids1 指向了新的slice, 导致我上面错误的理解.
// 如果 slice 不扩容, 还是一样的.
```



 





> **总结: 全是值传递, 区分值类型和引用类型. 和 java 完全一样.**
>
> **但是, 因为 map/slice 这种数据结构也是类似int 的关键字, 我没有分清楚, 我以为Go 里的都是值类型.**
>
> > > > > 带来困惑的原因是: JAVA 里全是指针, Go 中有指针, 有数据结构, 数据结构里还包括引用类型和值类型. 引用类型在赋值的时候, 也是值拷贝, 只是在传递成入参的时候, 是传递指针.
>
> **map[key] 这个是值拷贝. 在内存里拷贝了一个 value. value 不管是值类型还是引用类型, 都被拷贝了.** 
>
> **所以map[key] 和 value 是不同的地址.**
>
> slice[index] 也是值拷贝. 取值都是值拷贝. 拷贝的都是里面的真实数据结构, 不像 java, 拷贝出来的都是指针(基础类型做被包装了). 
>
> **但是 slice 拷贝出来的是slice 的结构值, 两个 slice 用的 arr 都是同一个, 线程不安全的!**
>
> > > **value = arr(index)**
> > >
> > > JAVA: value == arr(index), 只是拷贝了value 的指针, 
> > >
> > > Go: value != arr[index], 如果 value 不是指针, 拷贝的就是真实的数据结构

证明: 

```go
	var sslice1 = make([][]string, 0)
	sslice1 = append(sslice1, make([]string, 0, 5))
	sslice1 = append(sslice1, make([]string, 0, 5))
	sslice1 = append(sslice1, make([]string, 0,5 ))
	var slice1 = sslice1[0]  // 整个数据结构值拷贝出来, 和我想的引用类型不一样. java 里面的引用类型, 变量就是指针, 取出来对应的都是一个对象. Go 里面变量是对象, 只是引用类型, 取出来就是拷贝值出来.
	slice1 = append(slice1, "1")
	sslice1[0] = append(sslice1[0], "2")
	fmt.Printf( "slice: %+p\n", slice1)
```











## 总结: 我现在对 Go 的内存毫不知情. 现在的理解也有问题. 必须深入源码

