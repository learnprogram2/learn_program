## SQL执行计划



### 85. SQL的执行计划 和 性能优化

开发系统, 先设计表结构, 然后根据SQL设计索引, **然后分析查询SQL的执行计划 来 SQL优化**

每条SQL在查询优化器里面生成执行计划, 执行器会根据计划来查询: 哪张表, 用哪些索引, 如何排序和分组...

看懂执行计划, 就明白SQL优化的一半了. 



### 86.87. 执行计划 内容

**数据访问索引:** 基于索引树的二分查找.

- 直接通过聚簇索引/二级索引+回表的等值查询SQL, 在执行计划里称为 const: 常量级的查询

  - 二级索引必须是唯一索引才是**_const_**

  - 普通的非唯一索引叫做 **_ref_**

  - 非唯一的联合索引, 必须是从索引最左侧开始连续多列等值查询才是**_ref_**, 

  - 使用**column is null** 之类的语法, 即使column是主键/唯一索引, 也只能 **_ref_**. 

    如果是非唯一的二级索引, 就是 **_ref_or_null_** 

- **const就是唯一索引等值查询**
- **ref就是普通索引等值查询.或者主键索引的is null**

- **_RANGE_: 范围查询, 普通索引.** 

**基于索引树的同级双向链表:**

- **_INDEX_: 要查的和条件都在索引里的查询(不需要回表).** 比如key(c1, c2, c3), 按照c3查询c1,c2, 就会遍历叶子节点. 把索引数据拿出来就好了. 

**全表扫描:**

- **_ALL_**





### 88-90. SQL语句的执行计划举例

**常用的使用部分/多个索引的查询:** 

> TODO: `select * from table where c1='x1' and c2 >='x2';`
>
> - 如果有联合索引key(c1, c2), 会按照联合索引查么
>
> - 如果有两个联合索引 key1(c1, cc), key2(c2, cc); 那么MySQL的查询优化器会选择扫描行数少的.
>   - 比如: 按照等值`c1=x1`查询出数据, 放在内存里, 做`c2>=x2`的筛选



> `select * from table where c1 = x1 and c2 >= x2 and c3 IS NOT NULL;`
>
> - 比如c1是有索引, 其他字段没有索引. 执行计划会 根据c1做 ref访问, 然后回表拿到数据, 放在内存里做 `c2>x2` 和 `c3 IS NOT NULL` 的筛选. 
>
>   所以性能取决于有索引的那个的筛选度.



> `select * from table where c1='x1' or c2 >='x2`:
>
> todo: 老师讲解: 如果两个字段都是单独索引, 可能会使用两个, 也可能一个, 然后做并集.



**特殊SQL:** 特殊情况: 一个SQL可用多个二级索引.

> `select * from table where c1=xx and c2=xx;` c1, c2 都有单独索引.
>
> 执行计划: 对key(x1), key(x2)两个索引树都查找一遍, 按照内存做交集, 然后回表.

- 同一SQL里用多个索引有要求: 
  - **联合索引:** 必须把联合索引每个字段都等值匹配. 
  - 主键查询: 主键查询+其他二级索引等值匹配. 
  - 普通索引: 两个都等值查询



**嵌套循环关联(nested-loop join):** 两个表一起执行关联, 会现在驱动表里根据where条件筛选一部分数据, 然后对这部分数据循环, 每条数据到另一个被驱动表里 根据on和where条件筛选查找数据. 三张表join就是嵌套两次. 

- 对于join语句, 尽量给两个表都加上索引, 嵌套循环在索引里.



**总结四种查询方式:**

- const, ref, range: 都是扫描索引, 性能不错.
- index: 遍历二级索引的叶子节点, 比较慢
- all: 全表扫描: 数据量大, 慢. 

- 多个索引树查找: 用区分度高的, 或者等值查询, 用两个索引. 
- join: 嵌套循环.





### 91-93. 多表关联SQL执行

**基础关联语句的执行:**

> `select * from t1, t2 on t1.x1=t2.x1 where t1.x2=xxx and t2.x2=xxx`
>
> - 如果t1有10条数据, 每条在t2可以对应5条满足on条件, 那么sql会查出笛卡尔积10*5=50条数据. 
> - where条件: 对两个表做筛选. on条件: 对两个表做关联
> - **语义:** 从t1表里查出`t1.x2=xxx`的数据, 然后遍历, 再根据on条件和`t2.x2=xxx`去t2表里筛选. (其实是错的, 内关联对t1表里也有on条件)
> - **左侧表叫驱动表, 然后遍历去右侧的被驱动表查询.** 



**内关联:**

**上面的普通的关联语句, 其实就是内连接**. 两个表的数据必须满足on条件. 这个时候, 两侧表不满足on条件的数据不会被筛选到.

如果想查到一些, 比如左侧的表不筛选, 从右侧选(比如统计每一个用户的购买记录, 左侧用户表, 右侧记录表). 就是**外连接(outer join). 分为左外连接和右外连接.**  

**左外连接: 左边不做筛选, 都出来. 右外连接: 右边不做筛选.** 



**嵌套循环关联(nested-loop join): **

要加索引~





### 94-96. MySQL根据成本 _选择执行计划_

一条SQL总有很多执行计划可以选择, 再不济还能全表扫. 执行计划的选择是本小节讲的. 清楚了选择, 然后用explain查看真实的执行计划, 就可以更明白SQL的调优了.

**SQL的执行成本:**  磁盘IO缓存数据页(每页约定1.0), CPU成本做数据的筛选/排序(每条数据读取校验成本0.2) 

> `select * from table where x1=xx and x2=xx;` x1, x2分别是索引. 
>
> - 两个索引都能用, `都是possible keys`
>
> - 计算全表扫描成本: IO+CPU. 
>
>   可以`show table status like table` 可以看到表的统计信息, 里面rows(记录数)和data_length(聚簇索引的字节数大小, 除以1024*16就是数据页数) 可以估计全表扫描成本
>
>   **IO成本:** 数据页数 * 1.0 + Δ
>
>   **CPU成本:** 行记录数*0.2 + Δ
>
> - 一般只用一个索引, **要计算possible keys的成本:** 
>
>   **二级索引筛选数据的IO成本**(查询范围, 比如字段的[15, 20]区间)  一般一个范围区间就简单认为一个数据页, 所以索引预估的IO成本会很小. 
>
>   **CPU筛选成本:** 不太精确的估算. 估算可能筛选的数据量 * 0.2. 
>
>   **回表IO成本:** 简单地认为一条数据回表就是一个数据页. 数据条数*1.0
>
>   **回表后其他筛选的CPU成本:** 条数*0.2



> 单表主要根据表的多种访问方式来按照公式计算成本. 
>
> **多表关联的成本计算和计算的选择就是 分步走:** 左边驱动表有多个单表执行计划, 进行单表选择, 然后执行完后筛选的数据 要遍历去右表筛选, 去游标进行多个执行计划的筛选.



### 97-99. MySQL根据规则 _优化执行计划_

**不同的执行计划可能根据成本选择最好的, 也可能根据规则优化出来.** 

MySQL在执行一些复杂SQL语句的时候, 会对查询SQL进行重写, 优化执行计划..

- 去掉无关紧要的括号. 
- 调整查询条件: 比如 i=5 and j>i, 调整为`i=5 and j>5`, 删掉无用的条件. 
- 连表查询, 左侧一条, 会先把它查出来换成条件, 变成单表查询. 



**子查询是如何执行和优化的:**

> **父子无关子查询:** `select * from t1 where x1 = (select x1 from t2 where id=xxx)`
>
> - 先执行子查询, 后执行外层查询. 和单表一样
> - 在排序/分组/聚合之类的操作, 如果用不上索引会基于内存/临时文件执行.



> **基于父查询的子查询:** `select * from t1 where x1 = (select x1 from t2 where t1.x2=t2.x2);` 
>
> - 遍历t1每条数据, 取出子查询要用的条件(x2), 然后放到子查询执行, 然后用结果执行父查询.
> - 相当于三层嵌套. 



> **子查询是IN的临时表优化:** `select * from t1 where x1 in (select x2 from t2 where x3=xx)`
>
> - 先执行子查询, 然后对父查询全表扫描筛选IN. 效率非常低.
> - 优化: 
>   - 先执行子查询, 结果放入**临时表**, 基于memory存储引擎存放(太大就用B+聚簇索引放), 这个**临时表建立索引. 然后变成连表利用临时表的索引查询**, 不用in里面遍历了.
>   - **in创建的 左右的两张表, 也可以交换过来.** 



> **子查询的半连接(semi join)优化:** 
>
> `select * from t1 where x1 in (select x2 from t2 where x3=xx)`
>
> 半连接: `select t1.* from t1 semi join t2 on t1.x1=t2.x2 and t2.x2 = xxx`
>
> - semi join: 是MySQL内核使用的语法, in和join这种情况两个完全等价. 
> - 有很多限制, 了解一下这种变化即可. 



### 100-108. 使用 explain 查看 SQL执行计划

[博客](https://www.cnblogs.com/tufujie/p/9413852.html)

- 每条SQL都会进行成本选择和规则优化, 拿到最好的执行计划.
- 执行计划 就是 底层的 访问表的先后顺序 和 访问使用的索引/全表扫, 回表操作...

![image-20200919132750862](week10-SQL%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92.assets/image-20200919132750862.png)

如果单表查询, 就一条访问计划. 

```text
1. id: 执行计划的id, 复杂SQL会有多条计划
2. select_type, table, partition: 就是查询类型, 查的表, 表的分区
3. type: 表的访问方式: const, ref, range, index, all.
4. possible_keys: 和type搭配就可以确定访问方式了. 
5. key, key_len: 实际选择的possible_key, 还有索引字段的长度. 
6. ref: 使用某个字段的索引进行等值匹配的时候, 目标值的信息
7. rows, filtered: 预计读取的数据量, 剩余数据比例.
8. extra: 额外信息.
```



**2-3. 执行计划分析**

> `select * from t1` 的执行计划是: 
>
> ![image-20200919135647865](week10-SQL%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92.assets/image-20200919135647865.png)
>
> - 首先id是一, 简单的select, 查询的是t1表, 没有分区.
> - type: all, 全表扫描. 没有用到key. 就要全扫聚簇索引
> - 预计扫描3457条数据, 然后100%都符合条件. 



> `explain select * from t1 join t2 `的执行计划
>
> ![image-20200919140026166](week10-SQL%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92.assets/image-20200919140026166.png)
>
> - 两条计划, 要扫描两个表, id都是一样的, 说明一条SQL. 子查询就是两条sql了. 
> - t1表all全表扫
> - t2表all全表扫, Extra里写了nested-loop要做笛卡尔积的.  



> `Select * from t1 where x1 IN (select x1 from t2) or x3='xxxx'`
>
> SQL有子查询条件, 然后还有字段条件.
>
> ![image-20200919140938161](week10-SQL%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92.assets/image-20200919140938161.png)
>
> - select_type分出父子查询了.  然后id也不一样了. 
> - 主查询里面是用的全表扫描
> - 子查询里面用的是x1索引, 做的index遍历索引树.



> `select * from t1 UNION select * from t2;` UNION查询
>
> ![image-20200919141433832](week10-SQL%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92.assets/image-20200919141433832.png)
>
> - 首先两个表里进行all查询
> - **然后UNION操作:** 把结果集去重, 临时表<union 1,2>(在extra信息里备注了临时表) 里面UNION RESULT(去重).



**4-9. 细致探究执行计划**

- id: 多个select句子就多个id, 一个select跨表了, 也是一个id.
- select_type: simple(单表或者多表连接), primary(主次查询的时候), subquery, union(UNION), derived(临时表)...

- type: const, ref, range, index, all: 主键/唯一键等值查询, 二级索引等值查询, 二级索引range查询, 二级索引叶子节点扫, 聚簇索引扫.

  连表第二张表里还有eq_ref, 是被驱动表里基于主键等值匹配. (不是const)

  特殊情况单表查询会基于多个索引查, 然后取并集, 那就是 **index_merge**

  

- possible_keys: 可用的索引.
- key, key_len: 最终使用的索引, **索引字段的最大值长度.** 

- ref: 当值匹配查找(const,ref,eq_ref,ref_or_null) 的时候, ref就是等值匹配的内容: 常量(const)/另一个字段(table.column) 哈哈哈哈哈哈哈, 很清楚哦.
-  rows, filtered: 总条数, 和过滤剩下的比例.

- **extra:** 除了根据索引查询, 还要其他条件过滤, extra信息可能会很多. 

  - using index 和 using index condition. 使用索引就可以, 还是要额外筛选....

  - 全表扫, where有条件, 就备注了`using where`.

  - 多表关联的非索引关联: 使用join_buffer内存来优化, 减少被关联表的扫描次数. 就会备注上using join buffer(block nested loop)

  - `using filesort`和 `using temporary`

    基于索引的顺序来limit/order... 就是filesort. 比如使用索引排序, 就会这样. 

    没有办法才使用临时表IO操作就是temporary.

    

