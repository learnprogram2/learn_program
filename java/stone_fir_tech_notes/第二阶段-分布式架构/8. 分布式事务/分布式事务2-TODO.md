> **单体的XA(2PC,3PC) -> 微服务(TCC补偿事务) -> 本地消息表 -> Sagas事务模型.**
>
> **也就是从单体的一致性->微服务的最终一致性, CAP中的CP->AP追求avaliability**



## 流量充值系统微服务化拆分

### 40. 流量充值系统为什么要服务化

流量充值系统包含多个模块: 活动模块, 流量全模块, 积分模块, 抽奖模块, 充值订单模块, 套餐模块....

**多人维护单块系统不容易.**



### 41-43. 基于spring-cloud进行微服务化拆分改造







### 44. 微服务系统的分布式事务问题

![image-20210318201143090](%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A12.assets/image-20210318201143090.png)!



## *分布式事务常见解决方案 

### 45. 分布式事务常见解决方案 

1. **单块多库:XA协议->2PC**

   一般来说一个服务一个库.

2. **TCC方案: try->confirm->cancel三个阶段**

   **实现复杂, 需要编码耦合业务**, try和cancel回滚逻辑. **适合强一致性的数据要求**

3. **本地消息表-固化子事务**

   Ebay的方案, 父系统把需要操作的子事务们塞入MQ, 对应的子系统从中拿到自己的操作.

   子系统维护本地消息表, 子系统子事务操作成功后标记成功.

   父系统收集到所有的子系统事务成功确认消息后, 标记自己的事务成功.

   ![05_本地消息表方案](%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A12.assets/05_%E6%9C%AC%E5%9C%B0%E6%B6%88%E6%81%AF%E8%A1%A8%E6%96%B9%E6%A1%88.png)

   

4. **可靠消息最终一致性: 干脆依靠MQ固化子事务** 常用

   ![06_可靠消息最终一致性方案](%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A12.assets/06_%E5%8F%AF%E9%9D%A0%E6%B6%88%E6%81%AF%E6%9C%80%E7%BB%88%E4%B8%80%E8%87%B4%E6%80%A7%E6%96%B9%E6%A1%88.png)

   依赖MQ相比消息表要好一点.

5. **最大努力通知方案**

   把子事务推送到MQ就不管了

   专门事务协调者从MQ消费消息, 多次尝试调用子系统的子事务API, 直到所有成功.

![image-20210323222943974](%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A12.assets/image-20210323222943974.png)

- **普通API不要用分布式事务**
  - error-log记录
  - metrics监控和预警

- **资金, 交易, 订单主要API做分布式事务**





### 46. 分布式相关的理论: CAP 和 BASE.

1. CAP: consistency, avaliability, partition.

1. BASE: basic available, soft state, eventually consistency: 基本可用, 最终一致性. 软状态: 中间状态



### 47. 比较各分布式事务方案, 应用到流量充值中心. 

1. XA的2PC, 适合单块多库, 不适合分布式

2. **TCC: try-commit-cancel: 我感觉是2PC的分布式模式**

   **适合数据一致性要求很高, API阻塞时长不会太长的. 流量不太大的.**

   适合我们的下单服务, 不适合抢购阻塞资源. 

   可以用TCC事务把转账, 创建订单, 抽奖机会, 积分, 返券等核心逻辑包裹住.

3. 可靠消息最终一致性方案: 

   使用MQ代替消息表, 实现数据一致性. 本质不算事务方案.

   **适合TCC的补充, 流量大的, 阻塞长的数据一致性方案, 同时数据一致性等级要低一点.**

4. 最大努力通知方案:

   也挺好, 及时性要求不太高的, 数据一致性要求不太高的, 都可以走. 不太常用.

5. 适合分布式长事务的sagas方案.





## TCC事务了解

### 48. TCC分布式事务的具体技术方案和变种.

- **普通TCC:**

1. try: 锁定资源
2. confirm: 提交资源
3. cancle: 回滚

![12_TCC方案细节](%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A12.assets/12_TCC%E6%96%B9%E6%A1%88%E7%BB%86%E8%8A%82.png)



- **异步确保型TCC**:

类似于最大努力通知方案, 添加一个可靠消息服务, try-confirm-cancel不直接调用从业务了, 而是把操作都发送到MQ里, 然后可靠消息服务再异步的最大努力通知...

- **补偿性TCC:**

**把try-cofirm两个接口合并成一个, 直接提交, 然后有问题cancel.**



### 49. TCC落地细节.

1. **接口拆分**, 从业务服务的接口拆分成try-confirm-cancel三个接口.

   - try接口: 准备资源, 比如转账要扣除资金.
   - confirm: 就是原来的业务方法, 该干什么干什么, 我觉得就是把资源彻底扣除就好了.
   - cancel: 回滚方法, confirm反着来.

2. **改造特殊情况:**

   - cancel要多判断: 万一try根本没执行, 回滚就是空的.

   - 接口顺序保证, 幂等性保证: 如果先调用confirm就要顺序保证让他失败, 多次调用需要幂等.

     幂等性保证可以使用zk



### 50. 国内热门TCC框架介绍

- Himly
- ByteTCC



## TCC框架研究 TODO

### 51-56. 授人以渔: ByteTCC的了解: demo->源码->文档 TODO







## 微服务项目改造: 加入TCC分布式事务 TODO

### 57-64. 流量充值项目引入TCC分布式事务 TODO









## ByteTCC 源码 TODO

### 66-80. 

![13_猜测的tcc事务框架的实现原理](%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A12.assets/13_%E7%8C%9C%E6%B5%8B%E7%9A%84tcc%E4%BA%8B%E5%8A%A1%E6%A1%86%E6%9E%B6%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86.png)







## TCC对复杂链式调用的支持-TODO

### 81. 复杂的链式调用: 流量项目引入账单服务

上面的案例是A调用多个微服务, 没有涉及到链式调用.

比如: 充值->扣款->财务->... 之类的链式调用.

类似于两者的TCC调用,链式的两者TCC调用.

![18_服务链式调用的分布式事务解决方案](%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A12.assets/18_%E6%9C%8D%E5%8A%A1%E9%93%BE%E5%BC%8F%E8%B0%83%E7%94%A8%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88.png)



### 84-86. 链式调用源码 TODO



























