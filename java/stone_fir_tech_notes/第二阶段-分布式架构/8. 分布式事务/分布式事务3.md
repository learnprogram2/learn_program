## 分布式事务(数据一致性解决方案

**XA-2PC: 强一致性**

***TCC: 稍强一致性**

***可靠消息最终一致性: MQ解耦的非链式调用数据一致性场景.**

**最大努力通知方案: 非强一致性要求的异步数据一致性场景.**

**Saga: 类似TCC的稍强一致性**







# Saga: 复杂链式调用模式

### 87. saga分布式事务介绍和两种实现模型

![19_saga事务的原理](%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A13.assets/19_saga%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%8E%9F%E7%90%86.png)



1. **编排模式:** 事件驱动, 异步MQ监听响应对应动作.
   - 解耦, 可插拔.
   - 太麻烦, 引入MQ复杂性增加. 排查也麻烦.
2. **命令模式:** 添加Saga事务管理器, 通过集中调度, 减少MQ之类的复杂性.



### 88. DDD 和 eventSourcing, CQRS 和 Saga

1. aggregate: 聚合, 像是log一样, 把所有的数据聚合在一起才是整体的.
2. event sourcing: 每个事件一条记录
3. Actor模型: 单线程+mailbox的模型, scala的并发模型, 然后akka框架的概念
4. CQRS: command query responsibility segregation: 命令和查询责任分离模型. 就是增删改和查询的功能分开设计.->读写分离
5. eventSourcing + CQRS: 每个event都要同步到ES/HBase之类的SSTable里面聚合起来, 提供聚合数据查询.
6. axonFramework 是CQRS的实现.



### 89.  AxonFramework介绍和国内saga事务情况



- saga和TCC类似
- 要么选sage要么选TCC, saga要慎重.







## 可靠消息最终一致性方案 - 解耦重操作

### 90. 整体架构和核心流程设计

> 1. XA-2PC: 单系统多库, 事务
> 2. TCC事务: 服务间链式调用, API场景.
> 3. saga事务: 类似TCC
> 4. 可靠消息最终一致性方案: 耗时操作
> 5. 最大努力通知方案: 不要求一定完成的操作.
>
> - **考虑: 在十多个服务链式调用的核心链路场景, 单纯依靠可靠消息最终一致性方案太复杂了.**
> - **一般实现: TCC事务和可靠消息最终一致性方案结合使用, 对于调用链的分布式事务使用TCC, 对于耗时的子事务使用异步化的可靠消息最终一致性方案.**
> - 最好只用简单的MQ机制, 把控制和核心机制都放在自己掌握里.

**核心组件:**

1. 上游服务-producer: 操作DB事务A
2. 可靠消息服务: 自己开发的, 保证消息可靠记录和流转的服务.
3. MQ中间件:
4. 下游服务-consumer: 操作DB事务B

**执行流程:![20_可靠消息最终一致性方案](%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A13.assets/20_%E5%8F%AF%E9%9D%A0%E6%B6%88%E6%81%AF%E6%9C%80%E7%BB%88%E4%B8%80%E8%87%B4%E6%80%A7%E6%96%B9%E6%A1%88.png)**

1. producer发送待确认消息给"可靠消息服务", 存在DB里.

2. producer操作本地事务, 根据操作结果告知可靠消息服务是否继续下个子事务.

3. 如果失败了把消息删除就好了

4. 如果成功了, 消息服务要把消息流转到下一个状态"已发送", 发送到MQ中间键里. 这两步必须是本地事务.

   先存DB, 再发MQ, 保证发MQ失败能回滚.

5. consumer监听MQ, 在本地操作MQ的内容(子事务). 

6. consumer完成子事务后响应ACK给MQ, 这个必须包含在consumer的子事务里, 如果失败就回滚事务.

   MQ必须是手动ACK.

7. 可靠消息服务接收到ACK的MQ之后, 对DB存储的消息进行状态流转: success.

- 类似于2PC+MQ最大努力通知方案.



### 91. 如何处理不同环节消息投递失败

1. producer发送待确认消息给可靠消息服务的时候失败了:

   第一步失败, 整体事务的第一个子事务就失败了. 没事

2. 如果producer执行事务失败, 通知可靠消息服务cancel之前的消息, 这个时候失败.

   "待确认"状态的消息一直在可靠消息服务的DB里



### 92. 回调确认和消息重投机制

1. **对于步骤四的失败, 可靠消息服务内始终含有中间状态的消息:**

   producer应该暴露事务结果查询接口, 然后可靠消息服务增加超时回调机制.



### 93. 基于幂等性消息重投机制

1. **对于步骤678出的问题, consumer不会发送ack消息**

   - **可靠消息服务对长期没有得到ACK的消息要执行重投**
   - **前提是下游consumer要保证幂等性**, 多次消费相同消息不会再执行, 而且要重新返回ACK

   ![20_可靠消息最终一致性方案(2)](%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A13.assets/20_%E5%8F%AF%E9%9D%A0%E6%B6%88%E6%81%AF%E6%9C%80%E7%BB%88%E4%B8%80%E8%87%B4%E6%80%A7%E6%96%B9%E6%A1%88(2).png)





### 94. RocketMQ对分布式事务的支持

rocketMQ把可靠消息服务整合在MQ里面, 在实现可靠消息最终一致性方案的时候, 不用编写可靠消息服务了.



### 95. RabbitMQ的事务支持

不要用MQ的事务, 用ACK机制的atleastOnce就好了.



### 96. 流量充值服务的最终充值-可靠消息最终一致性方案实践

订购成功了, 就必须充值成功. 而且运营商BOSS系统交互很慢, 最适合用可靠消息服务最终一致性. 

producer是我们之前的订购服务的事务, consumer是和BOSS对接的服务.





## 开发: 流量充值项目开发可靠消息最终一致性 TODO

### 97-107. 

### 97. 

**缺陷:**

1. 使用DB-Mysql是高并发的瓶颈., 可以用redis/zk/hbase替代.
2. 引入复杂度, 慎用. 只有在涉及到资金/订单不能出错的再用.









## 最大努力通知方案 - TODO



### 108. 最大努力通知方案-不是事务的事务

![21_最大努力通知方案](%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A13.assets/21_%E6%9C%80%E5%A4%A7%E5%8A%AA%E5%8A%9B%E9%80%9A%E7%9F%A5%E6%96%B9%E6%A1%88.png)











## 总结:

（1）Spring事务框架

（2）XA分布式事务：单系统多数据库的场景

（3）TCC分布式事务：解决的就是大多数的分布式事务场景，服务链式调用

（4）可靠消息最终一致性方案：重要必须执行成功，但是耗时，可以接受异步化

（5）最大努力通知方案：耗时，可以接受异步化，而且可有可无，可以接受失败不成功



## **Seata**???

