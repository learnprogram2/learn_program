### 156-157. 秒杀架构整体实现过程和思路

1. **配置秒杀商品接口:** 

   要配置 秒杀场次, 秒杀商品, 库存, 价格

2. 秒杀服务

3. 秒杀下单服务

4. 下单服务改造, 为秒杀服务提供接口



第一阶段：架构设计和方案设计

第二阶段：秒杀系统的编码实现

第三阶段：秒杀核心服务与真实电商平台适配和改造，部署生产环境实战





### 160-165. 秒杀系统工程架构

《166_关于秒杀系统使用Spring Cloud Netflix老版本的问题说明》

 spring cloud alibaba

 儒猿技术窝，spring cloud alibaba技术栈的微服务专栏，9.9

 nacos+dubbo整合起来，nacos三节点集群部署



### 167-173. 运营服务: 配置秒杀活动接口



### 174-175. 部署多个单节点Redis的集群



### 176-178. 封装Jedis client, 创建通用工程



### 179-181 运营服务: 场次和商品的缓存双写: 应该包在事务里

```java
/**
  * 增加秒杀商品: DB和缓存双写: 应该把这个方法包在事务里面.
  */
public void add(SeckillProduct seckillProduct) {
    seckillProductDAO.add(seckillProduct);

    // 留一个作业：之前讲解了redis的各种数据结构的实战，大量的小案例的演示
    // 参考京东的秒杀页面，每一天有很多的场次，在redis里需要用一个数据结构维护一天的场次
    // 每一个场次是有很多的商品的，需要有一个数据结构维护一个场次内的很多商品
    // 这个应该怎么去做

    JedisManager jedisManager = JedisManager.getInstance();
    Jedis jedis = jedisManager.getJedis();
    jedis.lpush("seckill::products::" + seckillProduct.getSessionId(),
                JSONObject.toJSONString(seckillProduct));
}
```





### 183-184.本地MQ启动并加入代码 





### 185-189. 秒杀服务发送下单请求到MQ



### 190. 秒杀商品页面渲染服务 代码逻辑

**freemark模板渲染参数.**

```java
// 监听秒杀商品变动的MQ消息, 然后使用FreeMark渲染html页面, 推送到
consumer.registerMessageListener(new MessageListenerConcurrently() {

    @Override
    public ConsumeConcurrentlyStatus consumeMessage(List<MessageExt> messageExts,
                                                    ConsumeConcurrentlyContext context) {
        for(MessageExt messageExt : messageExts) {
            System.out.println(new String(messageExt.getBody()));

            // 得知，秒杀场次里增加的是哪个商品
            String seckillProductJSON = new String(messageExt.getBody());
            JSONObject seckillProductJSONObject = JSONObject.parseObject(seckillProductJSON);

            // 应该是调用商品中心的接口，获取你需要的商品的全部数据过来
            Long productId = seckillProductJSONObject.getLong("productId");
            Double seckillPrice = seckillProductJSONObject.getDouble("seckillPrice");
            Long seckillStock = seckillProductJSONObject.getLong("seckillStock");

            // 使用freemarker模板引擎把商品数据渲染到一个html模板里去
            FreemarkerHelper viewEngine = new FreemarkerHelper();

            Map<String, Object> paras = new HashMap<String, Object>();
            paras.put("productId", productId);
            paras.put("seckillPrice", seckillPrice);
            paras.put("seckillStock", seckillStock);

            String html = viewEngine.parseTemplate("autolist.ftl", paras);

            // 渲染得到的静态html页面文件scp传输到nginx服务器的指定目录下去
            System.out.println("将渲染完毕的秒杀商品html页面写入磁盘文件......");
            System.out.println(html);
            System.out.println("将磁盘上的html文件使用scp命令传送到nginx服务器上去......");

            // 调用你的云厂商的CDN产品的API，让CDN刷新一下静态页面的缓存
            System.out.println("调用CDN产品的API，让CDN刷新一下静态页面的缓存.......");
        }
        return ConsumeConcurrentlyStatus.CONSUME_SUCCESS;
    }
});

```



### 191. 测试: 秒杀请求->秒杀服务->MQ, 渲染HTML页面







## 192-209 - 秒杀库存服务 + 秒杀流程



### 193-200. 秒杀商品库存服务的代码逻辑





### 204. 秒杀课程价值:

1.  整体的业务架构+技术架构
2. 超高并发的架构设计

3. 超高并发场景下的高可用架构设计

4. （可选）真实电商业务流程下的秒杀系统完善

5. （可选）真实每秒1w+并发下的秒杀系统的生产实践



### 205-209. 回顾秒杀架构 和 秒杀流程

















