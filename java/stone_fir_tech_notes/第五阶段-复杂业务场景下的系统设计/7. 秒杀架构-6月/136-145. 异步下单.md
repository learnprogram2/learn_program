### 136. 为什么用MQ来削峰

- **减少订单系统压力, 让几台机器就可以支撑著, 减少资源.**







### 137. 异步下单的流量控制 - 秒杀下单服务线程池 控制对订单服务的并发



### 138. 前端 确定 订单状态: 被拦截的请求 和 受理中的请求

- **在nginx+lua中被拦截的请求:** 直接返回错误码, 请求不合理, 或者什么的. 
- **到后端没抢到redis库存的请求:** 正常的库存没有了, 抢购失败了.
- **正在受理中的请求:** 返回正在处理订单什么的, 不要离开界面, 前端不断轮询订单状态, 看订单是否创建成功.





### 139. 下单成功后 -> 订单等待支付 -> 超时取消订单

- **秒杀订单调用订单服务创建订单成功 -> 在扔进延时队列/设置定时任务, 超时取消订单**

- **前端轮询好订单创建完毕了,** 

1. 支付订单. 
2. 没有支付订单-> 30分钟后 取消订单.



### 140. MQ在秒杀架构中的担忧: 消息0丢失, 不重复, 不积压

要保证MQ里的消息0丢失, 消息不会重复, 消息积压问题, 高可用架构, 等等.

1. **消息0丢失**
2. **消息不能重复**
3. **消息不要积压**





### 141. 消息0丢失保证 TODO 复习学习

Kafka存在丢消息的问题，消息丢失会发生在Broker，Producer和Consumer三种。 分三步保证



### 142. 消息不重复消费: ID+校验

1. **阻止用户重复下单:** 秒杀服务写redis的时候, 要保证一个用户只能下限制次的单, 防止重复发消息

   `秒杀场次id + 商品id + 用户id + 订单类型` 组成唯一索引, 可以筛选出来.

2. **秒杀下单服务校验订单唯一索引**: 保证同一个订单不会重复消费. 可以在redis里面校验key什么的.



### 143-145. 消息积压, 订单延迟 解决方案: 积压检测 + 降级订单置失败 + 释放库存

- **订单查询优化**: 

  秒杀订单服务, 可以先不用把订单写入订单系统去, 直接把订单写入到redis里去, 然后让用户直接基于redis来查询订单. 让用户可以先查看支付

- **积压检测+积压降级方案:** 

  **秒杀下单服务消费MQ秒杀请求, 做一个积压检测的方案**, 如果超过2分钟, 认为订单出现挤压, **可以直接在redis订单里面置为失败**

- **前端超时失败方案:** 

  如果超过3分钟还没拉取到订单下成功的通知, 可跳转失败降级界面, 秒杀抢购失败,

- **积压降级要释放库存:**

  在秒杀下单服务检测到积压的时候, 需要释放秒杀服务的订单.

- **不要释放正常的订单**

  不要完全去释放库存，可以把一部分通知继续正常去下订单，同时还在不停的释放库存



![秒杀系统架构图 (136-145.%20%E5%BC%82%E6%AD%A5%E4%B8%8B%E5%8D%95.assets/%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%9B%BE%20(3).png)](136~155%E8%B5%84%E6%96%99/145_MQ%E6%B6%88%E6%81%AF%E7%A7%AF%E5%8E%8B%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E4%B8%8E%E7%A7%92%E6%9D%80%E8%AE%A2%E5%8D%95%E5%BB%B6%E8%BF%9F%E9%97%AE%E9%A2%98%EF%BC%883%EF%BC%89/%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%9B%BE%20(3).png)

![image-20210622142542764](136-145.%20%E5%BC%82%E6%AD%A5%E4%B8%8B%E5%8D%95.assets/image-20210622142542764.png)



