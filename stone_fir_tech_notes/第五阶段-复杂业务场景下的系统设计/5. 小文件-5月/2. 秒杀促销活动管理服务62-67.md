### 62. 互联网公司的秒杀活动: 运维管理, 活动流程什么的

![image-20210618173238028](2.%20%E7%A7%92%E6%9D%80%E4%BF%83%E9%94%80%E6%B4%BB%E5%8A%A8%E7%AE%A1%E7%90%86%E6%9C%8D%E5%8A%A162-67.assets/image-20210618173238028.png)

1. **秒杀的业务: 秒杀场次(时间), 商品, 价格(折扣), 数量**
2. 后台管理的CRUD页面

3. **活动数据: 数据库+缓存双写**

   在你配置好了秒杀活动以及通过了审核之后，就把这个秒杀活动的数据直接灌入到Redis缓存里去，接着呢，你对外提供的秒杀活动的查询接口，其实可以直接就从Redis里把数据搂出来

4. **Redis数据结构:**

   1. 秒杀场次信息: k=`seckil:{场次/时间}:rounds` v: list 存储有序的秒杀场次信息. 
   2. 秒杀场次信息: k=`seckill:round:{场次}:info`, value: hash=秒杀商品基本信息, Id什么的
   3. 秒杀商品信息: k=`seckill:round:{场次}:products`, value: list, 商品集合什么的.
   4. 单个商品信息: k=`seckill:round:{场次}:{productId}:info`, value: str, 商品信息.

5. **规律的秒杀活动**

   可以做一份完整的缓存，就是说某一次查询你的秒杀活动场次列表和商品列表的时候，把你完整的一份数据都拼装好，拼装成一个超大的字符串放在Redis里面.

   客户端做一个缓存，尽可能先用这份缓存好的完整数据去展示就可以了，比如APP端每隔5分钟做一个过期，在服务端让这份完整拼装好的大缓存数据，包含了当天所有的场次和商品，缓存过期时间可以设置为10分钟，10分钟以后过期，就自动重新基于一大堆的key组装一份数据出来

6. **超级大秒杀活动:** 
   - 前端策略: ...
   - 负载均衡: 反向代理...
   - 异步下单: ...



