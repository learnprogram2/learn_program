## 一. 概述

### 第一章: 架构和设计的目的是什么

“软件架构的终极目标是，用最小的人力成本来满足构建和维护该系统的需求。”



### 第二章: 两个价值维度

行为价值: 按照需求, 完成系统功能.“是紧急的，但是并不总是特别重要” 

架构价值: 保持灵活(soft), 架构设计与形状无关. "重要, 不总是紧急"

“紧急的事情常常没那么重要，而重要的事情则似乎永远也排不上优先级”

1．重要且紧急
2．重要不紧急
3．不重要但紧急
4．不重要且不紧急



## 二. 基础构件: 编程范式

编程范式指的是程序的编写模式, 已终止出现过三种编程范式. 相比编程从二进制->汇编->编译->各种语言, 编程范式很确定.



### 第三章: 三种编程范式

每个编程范式的目的都是设置限制

结构化编程: “结构化编程对程序**控制权的直接转移**进行了限制和规范”, goto 

面向对象编程: “面向对象编程对程序**控制权的间接转移**进行了限制和规范。”, phlymorphism多态限制函数指针

函数式编程: “函数式编程对程序中的**赋值**进行了限制和规范” , 限制赋值.

“多态是我们跨越架构边界的手段，函数式编程是我们规范和限制数据存放位置与访问权限的手段，结构化编程则是各模块的算法实现基础。”



### 结构化编程

编程的难度比较高 -> 需要对自己的程序进行推导证明 -> 结构串联, 每个结构分块证明 -> 程序没问题

goto的某些用法 -> 模块无法递归 -> 拆分不了小模块

goto可以被替代, 因为任何程序的结构都可以表示为: 顺序, 分支(if-else), 循环(do). 

“可推导模块所需要的控制结构集与构建所有程序所需的控制结构集的最小集是等同的”

怎么证明小模块: 顺序结构/分支结构的正确性可以通过枚举法证明, 改输入看输出. 循环结构用归纳法, n推n+1



但是这种形式化的, 欧几里得式的证明, 不是证明结构化编程正确性的唯一手段. 

可以拆成多个小函数, 然后用测试来分别证明"足够正确".



赋予了我们“创造可证伪程序单元的能力。” 功能拆分



### 面向对象编程

“将函数调用栈中的数据迁移到了堆区域中”

面向对象编程是三项的有机结合: 封装, 集成, 多态.

**封装:** class把代码和代码相关的数据圈起来, 只对外暴露部分函数.

“Java和C#则彻底抛弃了头文件与实现文件分离的编程方式，这其实进一步削弱了封装性。”C是完美封装, 对于数据什么都看不见.

**继承:** 

**多态:** 接口, “多态其实不过就是函数指针的一种应用”, 用函数指针实现多态很危险, 需要遵守约定.

“我们认为面向对象编程其实是对程序间接控制权的转移进行了约束。”

多态 -> 控制/依赖反转

**对于软件架构师:**  面向对象 “通过引入接口的方式来进行反转。
通过这种方法，软件架构师可以完全控制采用了面向对象这种编程方式的系统中所有的源代码依赖关系”

**可以使一个系统模块化.** 





























